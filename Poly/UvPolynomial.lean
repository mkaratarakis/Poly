/-
Copyright (c) 2024 Sina Hazratpour. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sina Hazratpour
-/

import Poly.LCCC.BeckChevalley
import Poly.MvPolynomial


/-!
# Polynomial Functor

-- TODO: there are various `sorry`-carrying proofs in below which require instances of
`CartesianExponentiable` for various constructions on morphisms. They need to be defined in
`Poly.Exponentiable`.
-/

noncomputable section

open CategoryTheory Category Limits Functor Adjunction Over

variable {C : Type*} [Category C] [HasPullbacks C]

/-- `P : UvPoly C` is a polynomial functors in a single variable -/
structure UvPoly (E B : C) where
  (p : E ‚ü∂ B)
  (exp : CartesianExponentiable p := by infer_instance)

attribute [instance] UvPoly.exp

namespace UvPoly

variable {C : Type*} [Category C] [HasTerminal C] [HasPullbacks C]

instance : HasBinaryProducts C :=
  hasBinaryProducts_of_hasTerminal_and_pullbacks C

variable {E B : C}

/-- The constant polynomial in many variables: for this we need the initial object -/
def const [HasInitial C] (S : C) : UvPoly (‚ä•_ C) S := ‚ü®initial.to S, inferInstance‚ü©

def smul [HasBinaryProducts C] (S : C) (P : UvPoly E B) : UvPoly (S ‚®Ø E) (S ‚®Ø B) :=
  ‚ü®prod.map (ùüô S) P.p, sorry‚ü©

/-- The product of two polynomials in a single variable. -/
def prod (P : UvPoly E B) (Q : UvPoly E' B') [HasBinaryCoproducts C]:
    UvPoly ((E ‚®Ø B') ‚®ø (B ‚®Ø E')) (B ‚®Ø B') where
  p := coprod.desc (prod.map P.p (ùüô B')) (prod.map (ùüô B) Q.p)
  exp := sorry -- perhaps we need extra assumptions on `C` to prove this, e.g. `C` is lextensive?

/-- For a category `C` with binary products, `P.functor : C ‚•§ C` is the functor associated
to a single variable polynomial `P : UvPoly E B`. -/
def functor [HasBinaryProducts C] (P : UvPoly E B) : C ‚•§ C :=
    (Œî_ E) ‚ãô (Œ†_ P.p) ‚ãô (Œ£_ B)

/-Note (SH): Alternatively, we can define the functor associated to a single variable polynomial in
terms of `MvPoly.functor` and then reduce the proofs of statements about single variable polynomials
to the multivariable case using the equivalence between `Over (‚ä§_ C)` and `C`.-/
def toMvPoly (P : UvPoly E B) : MvPoly (‚ä§_ C) (‚ä§_ C) :=
  ‚ü®E, B, terminal.from E, P.p, P.exp, terminal.from B‚ü©

/-- The projection morphism from `‚àë b : B, X ^ (E b)` to `B`. -/
def proj' (P : UvPoly E B) (X : Over (‚ä§_ C)) :
  ((Œ†_ P.p).obj ((Over.pullback (terminal.from E)).obj X)).left ‚ü∂ B :=
  ((Over.pullback (terminal.from _) ‚ãô (Œ†_ P.p)).obj X).hom

def auxFunctor (P : UvPoly E B) : Over (‚ä§_ C)  ‚•§ Over (‚ä§_ C) := MvPoly.functor P.toMvPoly

/-- We use the equivalence between `Over (‚ä§_ C)` and `C` to get `functor : C ‚•§ C`.
Alternatively we can give a direct definition of `functor` in terms of exponentials. -/
def functor' (P : UvPoly E B) : C ‚•§ C :=  equivOverTerminal.functor ‚ãô P.auxFunctor ‚ãô equivOverTerminal.inverse

def functorIsoFunctor' [HasBinaryProducts C] (P : UvPoly E B) : P.functor ‚âÖ P.functor' := by
  unfold functor' auxFunctor functor MvPoly.functor toMvPoly
  simp
  sorry

/-- The projection morphism from `‚àë b : B, X ^ (E b)` to `B` again. -/
def proj (P : UvPoly E B) (X : C) : P.functor.obj X ‚ü∂ B :=
  ((Œî_ E ‚ãô Œ†_ P.p).obj X).hom

@[simp, reassoc (attr := simp)]
lemma map_proj {X Y : C} (P : UvPoly E B) (f : X ‚ü∂ Y) : P.functor.map f ‚â´ P.proj Y = P.proj X := by
  simp [proj, functor]

/-- Essentially star is just the pushforward Beck-Chevalley natural transformation associated to
the square defined by `g`, but you have to compose with various natural isomorphisms. -/
def star (P : UvPoly E B) (Q : UvPoly F B) (g : E ‚ü∂ F) (h : P.p = g ‚â´ Q.p) :
    Q.functor ‚ü∂ P.functor := by
  unfold functor
  have hsquare : g ‚â´ Q.p = P.p ‚â´ ùüô _ := by simpa [comp_id] using h.symm
  have bc := pushforwardBeckChevalleyNatTrans g Q.p P.p (ùüô _) hsquare Q.exp P.exp
  exact whiskerRight ((whiskerLeft (Œî_ F) ((whiskerLeft (Œ†_ Q.p)
    (baseChange.id B).symm.hom) ‚â´ bc)) ‚â´ (whiskerRight (baseChange.mapStarIso g).inv (Œ†_ P.p)))
      (Over.forget B)

variable (B)
/-- The identity polynomial functor in single variable. -/
@[simps!]
def id : UvPoly B B := ‚ü®ùüô B, by infer_instance‚ü©

/-- Evaluating the identity polynomial at an object `X` is isomorphic to `B √ó X`. -/
def id_apply (X : C) : (id B).functor.obj X ‚âÖ B ‚®Ø X where
  hom := ùüô (B ‚®Ø X)
  inv := ùüô (B ‚®Ø X)

variable {B}

/-- A morphism from a polynomial `P` to a polynomial `Q` is a pair of morphisms `e : E ‚ü∂ E'`
and `b : B ‚ü∂ B'` such that the diagram
```
  E ---P.p--> B
  |           |
  e           b
  |           |
  v           v
  E' --Q.p--> B'
```
is a pullback square. -/
structure Hom {E' B' : C} (P : UvPoly E B) (Q : UvPoly E' B') where
  e : E ‚ü∂ E'
  b : B ‚ü∂ B'
  is_pullback : IsPullback P.p e b Q.p

namespace Hom

open IsPullback

-- baseChange.isLimitPullbackConeId _
def id (P : UvPoly E B) : Hom P P := ‚ü®ùüô E, ùüô B, ‚ü®by aesop, ‚ü® sorry ‚ü©‚ü©‚ü©

def comp {E' B' E'' B'' : C} {P : UvPoly E B} {Q : UvPoly E' B'} {R : UvPoly E'' B''}
    (f : Hom P Q) (g : Hom Q R) : Hom P R where
  e := f.e ‚â´ g.e
  b := f.b ‚â´ g.b
  is_pullback := paste_vert f.is_pullback g.is_pullback

end Hom

/-- Bundling up the the polynomials over different bases to form the underlying type of the
category of polynomials. -/
structure Total (C : Type*) [Category C] [HasPullbacks C] where
  (E B : C)
  (poly : UvPoly E B)

def Total.of (P : UvPoly E B) : Total C := ‚ü®E, B, P‚ü©

end UvPoly

open UvPoly

/-- The category of polynomial functors in a single variable. -/
instance : Category (UvPoly.Total C) where
  Hom P Q := UvPoly.Hom P.poly Q.poly
  id P := UvPoly.Hom.id P.poly
  comp := UvPoly.Hom.comp
  id_comp := by
    simp [UvPoly.Hom.id, UvPoly.Hom.comp]
  comp_id := by
    simp [UvPoly.Hom.id, UvPoly.Hom.comp]
  assoc := by
    simp [UvPoly.Hom.comp]

def Total.ofHom {E' B' : C} (P : UvPoly E B) (Q : UvPoly E' B') (Œ± : P.Hom Q) :
    Total.of P ‚ü∂ Total.of Q where
  e := Œ±.e
  b := Œ±.b
  is_pullback := Œ±.is_pullback

namespace UvPoly

variable {C : Type*} [Category C] [HasTerminal C] [HasPullbacks C]

instance : SMul C (Total C) where
  smul S P := Total.of (smul S P.poly)

/-- Scaling a polynomial `P` by an object `S` is isomorphic to the product of `const S` and the
polynomial `P`. -/
@[simps!]
def smul_eq_prod_const [HasBinaryCoproducts C] [HasInitial C] (S : C) (P : Total C) :
    S ‚Ä¢ P ‚âÖ Total.of ((const S).prod P.poly) where
      hom := sorry
      inv := sorry
      hom_inv_id := sorry
      inv_hom_id := sorry

variable {E B : C}

def polyPair {Œì X : C} (P : UvPoly E B) (be : Œì ‚ü∂ P.functor.obj X) :
    Œ£ b : Œì ‚ü∂ B, pullback b P.p ‚ü∂ X :=
  let b := be ‚â´ P.proj X
  let be' : Over.mk b ‚ü∂ (Œî_ E ‚ãô Œ†_ P.p).obj X := Over.homMk be
  let be'' := (P.exp.adj.homEquiv _ _).symm be'
  let be''' : pullback b P.p ‚ü∂ E ‚®Ø X := be''.left
  ‚ü®b, be''' ‚â´ prod.snd‚ü©

def pairPoly {Œì X : C} (P : UvPoly E B) (b : Œì ‚ü∂ B) (e : pullback b P.p ‚ü∂ X) :
    Œì ‚ü∂ P.functor.obj X :=
  let pbE := (Œî_ P.p).obj (Over.mk b)
  let eE : pbE ‚ü∂ (Œî_ E).obj X := (Over.forgetAdjStar E).homEquiv _ _ e
  (P.exp.adj.homEquiv _ _ eE).left

/-! ## Generic pullback -/

/--
The UP of polynomial functors is mediated by a "generic pullback" [Awodey2017, p. 10, fig. 6].

```
     X
     ^
     | u‚ÇÇ
   genPb ---------------> E
 fst | ‚îò                  | p
     v                    v
P.functor.obj X --------> B
                P.proj X
```
-/
def genPb (P : UvPoly E B) (X : C) : C :=
  pullback (P.proj X) P.p

def genPb.fst (P : UvPoly E B) (X : C) : P.genPb X ‚ü∂ P.functor.obj X :=
  pullback.fst (f := P.proj X) (g := P.p)

def genPb.u‚ÇÇ (P : UvPoly E B) (X : C) : P.genPb X ‚ü∂ X :=
  have : P.proj X = (P.polyPair <| ùüô <| P.functor.obj X).fst :=
    by simp [polyPair]
  (pullback.congrHom this rfl).hom ‚â´ (P.polyPair <| ùüô <| P.functor.obj X).snd

/-- The second component of `polyPair` is a comparison map of pullbacks composed with `genPb.u‚ÇÇ`. -/
theorem genPb.polyPair_snd_eq_comp_u‚ÇÇ' {Œì X : C} (P : UvPoly E B) (be : Œì ‚ü∂ P.functor.obj X) :
    (P.polyPair be).snd = pullback.map (P.polyPair be).fst P.p (P.proj X) P.p be (ùüô _) (ùüô _) (by simp [polyPair]) (by simp) ‚â´
                          u‚ÇÇ P X := by
  simp only [polyPair, u‚ÇÇ, homEquiv_counit, comp_left, ‚Üê assoc]
  congr 2
  aesop_cat

/-- Universal property of the polynomial functor. -/
@[simps]
def equiv (P : UvPoly E B) (Œì : C) (X : C) :
    (Œì ‚ü∂ P.functor.obj X) ‚âÉ (b : Œì ‚ü∂ B) √ó (pullback b P.p ‚ü∂ X) where
  toFun := P.polyPair
  invFun := fun ‚ü®b, e‚ü© => P.pairPoly b e
  left_inv be := by
    simp_rw [polyPair, pairPoly, ‚Üê forgetAdjStar.homEquiv_symm]
    simp
  right_inv := by
    intro ‚ü®b, e‚ü©
    dsimp [polyPair, pairPoly]
    have := Over.forgetAdjStar.homEquiv (X := (Œî_ P.p).obj (Over.mk b)) (f := e)
    simp at this
    rw [this]
    set pairHat := P.exp.adj.homEquiv _ _ _
    congr! with h
    ¬∑ simpa [-w] using pairHat.w
    ¬∑ -- We deal with HEq/dependency by precomposing with an iso
      let i : Over.mk (pairHat.left ‚â´ P.proj X) ‚âÖ Over.mk b :=
        Over.isoMk (Iso.refl _) (by simp [h])
      rw [
        show homMk _ _ = i.hom ‚â´ pairHat by ext; simp [i],
        show _ ‚â´ prod.snd = (pullback.congrHom h rfl).hom ‚â´ e by (
          simp only [pullback_obj_left,
          mk_left, mk_hom, star_obj_left, pullback_obj_hom, const_obj_obj, BinaryFan.mk_pt,
          BinaryFan.œÄ_app_left, BinaryFan.mk_fst, id_eq, homEquiv_unit, id_obj, comp_obj,
          homEquiv_counit, map_comp, assoc, counit_naturality, left_triangle_components_assoc,
          comp_left, pullback_map_left, eqToHom_left, eqToHom_refl, homMk_left, prod.comp_lift,
          limit.lift_œÄ, eq_mpr_eq_cast, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app, comp_id,
          BinaryFan.œÄ_app_right, BinaryFan.mk_snd, pullback.congrHom_hom, pairHat]
          congr 1
          ext <;> simp [i])
      ]
      generalize (hasPullbackHorizPaste .. : HasPullback (pairHat.left ‚â´ P.proj X) P.p) = pf
      generalize pairHat.left ‚â´ _ = x at h pf
      cases h
      simp [pullback.congrHom]

/-- `UvPoly.equiv` is natural in `Œì`. -/
lemma equiv_naturality_left {Œî Œì : C} (œÉ : Œî ‚ü∂ Œì) (P : UvPoly E B) (X : C) (be : Œì ‚ü∂ P.functor.obj X) :
    equiv P Œî X (œÉ ‚â´ be) = let ‚ü®b, e‚ü© := equiv P Œì X be
                           ‚ü®œÉ ‚â´ b, pullback.lift (pullback.fst .. ‚â´ œÉ) (pullback.snd ..)
                                     (assoc (obj := C) .. ‚ñ∏ pullback.condition) ‚â´ e‚ü© := by
  dsimp
  congr! with h
  . simp [polyPair, pairPoly]
  . set g := _ ‚â´ (P.polyPair be).snd
    rw [(_ : (P.polyPair (œÉ ‚â´ be)).snd = (pullback.congrHom h rfl).hom ‚â´ g)]
    ¬∑ generalize (P.polyPair (œÉ ‚â´ be)).fst = x at h
      cases h
      simp
    ¬∑ simp only [polyPair, comp_obj, homEquiv_counit, id_obj, comp_left, pullback_obj_left,
      mk_left, mk_hom, star_obj_left, pullback_map_left, homMk_left, pullback.congrHom_hom, ‚Üê
      assoc, g]
      congr 2
      ext <;> simp

/-- `UvPoly.equiv` is natural in `X`. -/
lemma equiv_naturality_right {Œì X Y : C}
    (P : UvPoly E B) (be : Œì ‚ü∂ P.functor.obj X) (f : X ‚ü∂ Y) :
    equiv P Œì Y (be ‚â´ P.functor.map f) =
      let ‚ü®b, e‚ü© := equiv P Œì X be
      ‚ü®b, e ‚â´ f‚ü© := by
  dsimp
  congr! 1 with h
  . simp [polyPair]
  . set g := (P.polyPair be).snd ‚â´ f
    rw [(_ : (P.polyPair (be ‚â´ P.functor.map f)).snd = (pullback.congrHom h rfl).hom ‚â´ g)]
    ¬∑ generalize (P.polyPair (be ‚â´ P.functor.map f)).fst = x at h
      cases h
      simp
    ¬∑ dsimp only [polyPair, g]
      rw [homMk_comp (f_comp := by simp [proj, functor]) (g_comp := by simp [functor])]
      simp only [UvPoly.functor, Functor.comp_map, forget_map, left_homMk,
        homEquiv_naturality_right_symm, comp_left, assoc]
      rw [show ((Œî_ E).map f).left ‚â´ prod.snd = prod.snd ‚â´ f by simp]
      simp only [‚Üê assoc]
      congr 2
      simp only [comp_obj, forget_obj, star_obj_left, homEquiv_counit, id_obj, comp_left,
        pullback_obj_left, mk_left, mk_hom, pullback_map_left, Over.homMk_left,
        pullback.congrHom_hom, ‚Üê assoc]
      congr 1
      ext <;> simp

def foo [HasBinaryProducts C] {P Q : UvPoly.Total C} (f : P ‚ü∂ Q) :
    (Over.map P.poly.p) ‚ãô (Over.map f.b) ‚âÖ (Over.map f.e) ‚ãô (Over.map Q.poly.p) :=
  mapSquareIso _ _ _ _ (f.is_pullback.w)

def bar [HasBinaryProducts C] {P Q : UvPoly.Total C} (f : P ‚ü∂ Q) :
    (Œî_ f.e) ‚ãô (Œ£_ P.poly.p) ‚âÖ (Œ£_ Q.poly.p) ‚ãô (Œî_ f.b) := by
  set l := pullbackBeckChevalleyNatTrans P.poly.p f.b f.e Q.poly.p (f.is_pullback.w)
  have : IsIso l :=
    (pullbackBeckChevalleyNatTrans_of_IsPullback_is_iso P.poly.p f.b f.e Q.poly.p f.is_pullback)
  exact asIso l

def bar' [HasBinaryProducts C] {P Q : UvPoly.Total C} (f : P ‚ü∂ Q) :
    (Œî_ P.poly.p) ‚ãô (Œ£_ f.e) ‚âÖ (Œ£_ f.b) ‚ãô (Œî_ Q.poly.p) := by
  sorry

/-- A map of polynomials induces a natural transformation between their associated functors. -/
def naturality [HasBinaryProducts C] {P Q : UvPoly.Total C} (f : P ‚ü∂ Q) :
    P.poly.functor ‚ü∂ Q.poly.functor := by
  sorry


def comp [HasPullbacks C] [HasTerminal C]
    {E B D C : C} (P : UvPoly E B) (Q : UvPoly D C) : UvPoly (pullback Q.p (genPb.u‚ÇÇ P C)) (P.functor.obj C) :=
   {
     p :=  (pullback.snd Q.p (genPb.u‚ÇÇ P C)) ‚â´  (genPb.fst P C)
     exp := by sorry
   }

/-- The associated functor of the composition of two polynomials is isomorphic to the composition of the associated functors. -/
def compFunctorIso [HasPullbacks C] [HasTerminal C]
    {E B D C : C} (P : UvPoly E B) (Q : UvPoly D C) :
    P.functor ‚ãô Q.functor ‚âÖ (comp P Q).functor := by
  sorry

end UvPoly

end
