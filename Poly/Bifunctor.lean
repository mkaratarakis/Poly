import Mathlib.CategoryTheory.Functor.Currying

import Poly.Util
import Poly.Tactic.BanishCasts

import SEq.Tactic.DepRewrite

/-! # Bifunctors

We define some constructions on bifunctors (aka profunctors),
that is functors in two arguments.

Their utility in Poly is as a tool for packaging and composing natural equivalences.
For example, given `F,H : ùíû ‚ü∂ ‚Ñ∞` and `G,I : ùíü ‚ü∂ ‚Ñ∞`,
```
F(X) ‚ü∂ G(Y)
============
H(X) ‚ü∂ I(Y)
```
would be a natural isomorphism of bifunctors `ùíû·µí·µñ ‚•§ ùíü ‚•§ Type v`
given by `(X, Y) ‚Ü¶ F(X) ‚ü∂ G(Y)` and `(X, Y) ‚Ü¶ H(X) ‚ü∂ I(Y)`. -/

namespace CategoryTheory

variable {ùíû ùíü ‚Ñ∞ : Type*} [Category ùíû] [Category ùíü] [Category ‚Ñ∞]

/-- Natural isomorphism of bifunctors from naturality in both arguments. -/
def NatIso.ofComponents‚ÇÇ {F G : ùíû ‚•§ ùíü ‚•§ ‚Ñ∞}
    (app : ‚àÄ Œì X, (F.obj Œì).obj X ‚âÖ (G.obj Œì).obj X)
    (naturality_left : ‚àÄ {Œì Œî : ùíû} (X : ùíü) (œÉ : Œì ‚ü∂ Œî),
      (F.map œÉ).app X ‚â´ (app Œî X).hom = (app Œì X).hom ‚â´ (G.map œÉ).app X := by aesop_cat)
    (naturality_right : ‚àÄ {X Y : ùíü} (Œì : ùíû) (f : X ‚ü∂ Y),
      (F.obj Œì).map f ‚â´ (app Œì Y).hom = (app Œì X).hom ‚â´ (G.obj Œì).map f := by aesop_cat) :
    F ‚âÖ G :=
  NatIso.ofComponents
    (fun Œì => NatIso.ofComponents (app Œì) (fun f => by simpa using naturality_right Œì f))
    (fun œÉ => by ext X : 2; simpa using naturality_left X œÉ)

/-! ## Dependent functors -/

/-- A functor into `ùíü` that depends on `F`,
in other words `‚à´F ‚•§ ùíü` where all the `F(Œì)` are discrete,
spelled out in elementary terms.

(In the general case, we would have
`map : ‚àÄ ‚¶ÉŒì Œî‚¶Ñ ‚¶Éb : F.obj Œì‚¶Ñ ‚¶Éc : F.obj Œî‚¶Ñ
  (œÉ : Œì ‚ü∂ Œî) (f : F.map œÉ b ‚ü∂ c), obj b ‚ü∂ obj c`.)

Equivalently, it is a (lax or strict or something) transformation `F ‚ü∂ const ùíü`. -/
-- NOTE: A more mathlib-ready, general approach might use `‚à´F ‚•§ ùíü`,
-- and introduce a special-case constructor for discrete `F(Œì)`
-- with an argument for each field of this structure. -/
structure DepFunctor (F : ùíû ‚•§ Type*) (ùíü : Type*) [Category ùíü] where
  obj : ‚àÄ ‚¶ÉŒì‚¶Ñ, F.obj Œì ‚Üí ùíü
  map : ‚àÄ ‚¶ÉŒì Œî‚¶Ñ (œÉ : Œì ‚ü∂ Œî) (b : F.obj Œì), obj b ‚ü∂ obj (F.map œÉ b)
  map_id : ‚àÄ ‚¶ÉŒì‚¶Ñ (b : F.obj Œì), map (ùüô Œì) b = eqToHom (F.map_id _ ‚ñ∏ rfl) := by aesop_cat
  map_comp : ‚àÄ ‚¶ÉŒì Œî Œò‚¶Ñ (œÉ : Œì ‚ü∂ Œî) (œÑ : Œî ‚ü∂ Œò) (b : F.obj Œì),
    map (œÉ ‚â´ œÑ) b = map œÉ b ‚â´ map œÑ (F.map œÉ b) ‚â´ eqToHom (F.map_comp .. ‚ñ∏ rfl) := by aesop_cat

attribute [reassoc] DepFunctor.map_comp
attribute [simp] DepFunctor.map_id DepFunctor.map_comp DepFunctor.map_comp_assoc

@[simps]
def DepFunctor.isoLeft.{v} {F‚ÇÅ F‚ÇÇ : ùíû ‚•§ Type v} {ùíü : Type*} [Category ùíü]
    (F : DepFunctor F‚ÇÅ ùíü) (i : F‚ÇÇ ‚âÖ F‚ÇÅ) : DepFunctor F‚ÇÇ ùíü where
  obj Œì b := F.obj (i.hom.app Œì b)
  map Œì _ œÉ b := F.map œÉ (i.hom.app Œì b) ‚â´ eqToHom (FunctorToTypes.naturality F‚ÇÇ F‚ÇÅ i.hom .. ‚ñ∏ rfl)
  map_id _ b := by simp
  map_comp _ _ _ œÉ œÑ b := by
    slice_rhs 2 3 => rw [‚Üê eqToHom_naturality _ (by simp [FunctorToTypes.naturality])]
    simp

@[ext]
structure DepNatTrans {F : ùíû ‚•§ Type*} {ùíü : Type*} [Category ùíü] (G‚ÇÅ G‚ÇÇ : DepFunctor F ùíü) where
  app : ‚àÄ ‚¶ÉŒì‚¶Ñ (b : F.obj Œì), G‚ÇÅ.obj b ‚ü∂ G‚ÇÇ.obj b
  naturality : ‚àÄ ‚¶ÉŒì Œî‚¶Ñ (œÉ : Œì ‚ü∂ Œî) (b : F.obj Œì),
    app b ‚â´ G‚ÇÇ.map œÉ b = G‚ÇÅ.map œÉ b ‚â´ app (F.map œÉ b) := by aesop_cat

attribute [reassoc] DepNatTrans.naturality

@[simps]
instance (F : ùíû ‚•§ Type*) (ùíü : Type*) [Category ùíü] : Category (DepFunctor F ùíü) where
  Hom := DepNatTrans
  id G := { app := fun _ _ => ùüô _ }
  comp Œ∑ ŒΩ := {
    app := fun _ b => Œ∑.app b ‚â´ ŒΩ.app b
    naturality := by simp [Œ∑.naturality_assoc, ŒΩ.naturality]
  }

namespace DepNatTrans

variable {F : ùíû ‚•§ Type*} {ùíü : Type*} [Category ùíü] {Œì : ùíû} (b : F.obj Œì)

@[ext]
theorem ext' {G‚ÇÅ G‚ÇÇ : DepFunctor F ùíü} {Œ± Œ≤ : G‚ÇÅ ‚ü∂ G‚ÇÇ} (w : Œ±.app = Œ≤.app) : Œ± = Œ≤ :=
  DepNatTrans.ext w

@[simp]
theorem id_app (G‚ÇÅ : DepFunctor F ùíü) : (ùüô G‚ÇÅ : G‚ÇÅ ‚ü∂ G‚ÇÅ).app b = ùüô (G‚ÇÅ.obj b) := rfl

@[reassoc (attr := simp)]
theorem comp_app {G‚ÇÅ G‚ÇÇ G‚ÇÉ : DepFunctor F ùíü} (Œ± : G‚ÇÅ ‚ü∂ G‚ÇÇ) (Œ≤ : G‚ÇÇ ‚ü∂ G‚ÇÉ) :
    (Œ± ‚â´ Œ≤).app b = Œ±.app b ‚â´ Œ≤.app b := rfl

@[reassoc]
theorem naturality_app {‚Ñ∞ : Type*} [Category ‚Ñ∞] {G‚ÇÅ G‚ÇÇ : DepFunctor F (ùíü ‚•§ ‚Ñ∞)} (Œ± : G‚ÇÅ ‚ü∂ G‚ÇÇ)
    {Œì Œî : ùíû} (œÉ : Œì ‚ü∂ Œî) (b : F.obj Œì) (X : ùíü) :
    (G‚ÇÅ.map œÉ b).app X ‚â´ (Œ±.app (F.map œÉ b)).app X = (Œ±.app b).app X ‚â´ (G‚ÇÇ.map œÉ b).app X :=
  (congr_fun (congr_arg NatTrans.app (Œ±.naturality œÉ b)) X).symm

end DepNatTrans

namespace DepNatIso

variable {F : ùíû ‚•§ Type*} {ùíü : Type*} [Category ùíü] {G‚ÇÅ G‚ÇÇ : DepFunctor F ùíü}

@[reassoc (attr := simp)]
theorem hom_inv_id_app {Œì : ùíû} (Œ± : G‚ÇÅ ‚âÖ G‚ÇÇ) (b : F.obj Œì) :
    Œ±.hom.app b ‚â´ Œ±.inv.app b = ùüô (G‚ÇÅ.obj b) := by
  simp [‚Üê DepNatTrans.comp_app]

@[reassoc (attr := simp)]
theorem inv_hom_id_app {Œì : ùíû} (Œ± : G‚ÇÅ ‚âÖ G‚ÇÇ) (b : F.obj Œì) :
    Œ±.inv.app b ‚â´ Œ±.hom.app b = ùüô (G‚ÇÇ.obj b) := by
  simp [‚Üê DepNatTrans.comp_app]

instance hom_app_isIso {Œì : ùíû} (Œ± : G‚ÇÅ ‚âÖ G‚ÇÇ) (b : F.obj Œì) : IsIso (Œ±.hom.app b) :=
  ‚ü®Œ±.inv.app b, by simp‚ü©

instance inv_app_isIso {Œì : ùíû} (Œ± : G‚ÇÅ ‚âÖ G‚ÇÇ) (b : F.obj Œì) : IsIso (Œ±.inv.app b) :=
  ‚ü®Œ±.hom.app b, by simp‚ü©

def ofComponents
    (app : ‚àÄ {Œì} (b : F.obj Œì), G‚ÇÅ.obj b ‚âÖ G‚ÇÇ.obj b)
    (naturality : ‚àÄ {Œì Œî} (œÉ : Œì ‚ü∂ Œî) (b : F.obj Œì),
      (app b).hom ‚â´ G‚ÇÇ.map œÉ b = G‚ÇÅ.map œÉ b ‚â´ (app (F.map œÉ b)).hom) :
    G‚ÇÅ ‚âÖ G‚ÇÇ where
  hom := { app := fun _ b => (app b).hom }
  inv := {
    app := fun _ b => (app b).inv
    naturality := fun _ _ œÉ b => by
      have : (app b).inv ‚â´ (app b).hom ‚â´ G‚ÇÇ.map œÉ b ‚â´ (app (F.map œÉ b)).inv =
             (app b).inv ‚â´ G‚ÇÅ.map œÉ b ‚â´ (app (F.map œÉ b)).hom ‚â´ (app (F.map œÉ b)).inv := by
        simp [reassoc_of% naturality]
      simpa using this.symm
  }

end DepNatIso

/-! ## Dependent sum functors -/


/-- Given functors `F : ùíû ‚•§ Type v` and `G : ‚à´F ‚•§ ùíü ‚•§ Type v`,
produce the functor `(X, Y) ‚Ü¶ (b : F(X)) √ó G((X, b))(Y)`.
This is a dependent sum that varies naturally in its parameters `X, Y`. -/
@[simps!]
def Functor.Sigma.{v} {F : ùíû ‚•§ Type v} (G : DepFunctor F (ùíü ‚•§ Type v)) : ùíû ‚•§ ùíü ‚•§ Type v :=
  curry.obj {
    obj := fun (Œì, X) => (b : F.obj Œì) √ó ((G.obj b).obj X)
    map := fun (œÉ, f) ‚ü®b, e‚ü© =>
      ‚ü®F.map œÉ b, (G.map œÉ b).app _ ((G.obj b).map f e)‚ü©
    map_id := fun (Œì, X) => by
      refine funext fun ‚ü®b, e‚ü© => ?_
      dsimp
      congr! 1 with h
      . simp
      . simp only [FunctorToTypes.map_id_apply, DepFunctor.map_id]
        rw! [h]
        simp
    map_comp := fun {_} {_} {Y} (œÉ, f) (œÑ, g) => by
      refine funext fun ‚ü®b, e‚ü© => ?_
      dsimp
      congr! 1 with h
      . simp
      . simp only [FunctorToTypes.map_comp_apply, DepFunctor.map_comp]
        rw! [h]
        simp [FunctorToTypes.naturality]
  }

def Functor.Sigma.isoCongrLeft.{v} (F‚ÇÅ F‚ÇÇ : ùíû ‚•§ Type v) (G : DepFunctor F‚ÇÅ (ùíü ‚•§ Type v))
    (i : F‚ÇÇ ‚âÖ F‚ÇÅ) : Functor.Sigma G ‚âÖ Functor.Sigma (G.isoLeft i) :=
  NatIso.ofComponents‚ÇÇ
    (fun Œì X => Equiv.toIso {
      toFun := fun ‚ü®b, e‚ü© => ‚ü®i.inv.app Œì b, cast (by simp) e‚ü©
      invFun := fun ‚ü®b, e‚ü© => ‚ü®i.hom.app Œì b, e‚ü©
      left_inv := fun ‚ü®_, _‚ü© => by simp
      right_inv := fun ‚ü®_, _‚ü© => by simp
    })
    (fun X œÉ => by
      ext ‚ü®b, e‚ü©
      simp only [Sigma, DepFunctor.isoLeft_obj, prod_Hom, DepFunctor.isoLeft_map,
        FunctorToTypes.comp, curry_obj_obj_obj, curry_obj_map_app, FunctorToTypes.map_id_apply,
        Equiv.toIso_hom, Equiv.coe_fn_mk, types_comp_apply, eqToHom_app, Sigma.mk.inj_iff,
        FunctorToTypes.naturality, true_and]
      have : (i.hom.app _ (F‚ÇÇ.map œÉ (i.inv.app _ b))) = F‚ÇÅ.map œÉ b := by
        simp [FunctorToTypes.naturality]
      rw! (castMode := .all) [this, FunctorToTypes.inv_hom_id_app_apply _ _ i _ (F‚ÇÅ.map œÉ b),
        FunctorToTypes.inv_hom_id_app_apply _ _ i _ b]
      simp)
    (fun Œì f => by
      ext ‚ü®b,e‚ü©
      simp only [Sigma, DepFunctor.isoLeft_obj, prod_Hom, DepFunctor.isoLeft_map,
        FunctorToTypes.comp, curry_obj_obj_obj, curry_obj_obj_map, DepFunctor.map_id, eqToHom_app,
        Equiv.toIso_hom, Equiv.coe_fn_mk, types_comp_apply, Sigma.mk.inj_iff,
        FunctorToTypes.map_id_apply, true_and]
      rw! (castMode := .all) [show F‚ÇÅ.map (ùüô Œì) b = b by simp,
        show i.hom.app Œì (i.inv.app Œì b) = b by simp,
        show i.hom.app Œì (F‚ÇÇ.map (ùüô Œì) (i.inv.app Œì b)) = b by simp [FunctorToTypes.naturality],
        show F‚ÇÅ.map (ùüô Œì) b = b by simp]
      simp)

def Functor.Sigma.isoCongrRight.{v} (F : ùíû ‚•§ Type v) (G‚ÇÅ G‚ÇÇ : DepFunctor F (ùíü ‚•§ Type v))
    (i : G‚ÇÅ ‚âÖ G‚ÇÇ) :
    Functor.Sigma G‚ÇÅ ‚âÖ Functor.Sigma G‚ÇÇ :=
  NatIso.ofComponents‚ÇÇ
    (fun Œì X => Equiv.toIso {
      toFun := fun ‚ü®b, e‚ü© => ‚ü®b, (i.hom.app b).app X e‚ü©
      invFun := fun ‚ü®b, e‚ü© => ‚ü®b, (i.inv.app b).app X e‚ü©
      left_inv := fun ‚ü®b, e‚ü© => by
        -- simp doesn't finish this. missing simp lemma?
        have := congr_fun (congr_fun (congr_arg NatTrans.app (DepNatIso.hom_inv_id_app i b)) X) e
        simp only [NatTrans.comp_app] at this
        simpa using this
      right_inv := fun ‚ü®b, e‚ü© => by
        have := congr_fun (congr_fun (congr_arg NatTrans.app (DepNatIso.inv_hom_id_app i b)) X) e
        simp only [NatTrans.comp_app] at this
        simpa using this
    })
    (fun X œÉ => by
      ext ‚ü®b, e‚ü©
      have := congr_fun (DepNatTrans.naturality_app i.hom œÉ b X) e
      dsimp at this
      simp [Sigma, this])
    (fun Œì f => by
      ext ‚ü®b, e‚ü©
      simp only [Sigma, prod_Hom, curry_obj_obj_obj, curry_obj_obj_map, DepFunctor.map_id,
        eqToHom_app, Iso.app_hom, Iso.app_inv, Equiv.toIso_hom, Equiv.coe_fn_mk, types_comp_apply,
        Sigma.mk.inj_iff, FunctorToTypes.map_id_apply, heq_eq_eq, true_and]
      rw! [F.map_id Œì]
      simp [FunctorToTypes.naturality])

open Limits in
/-- The functor `(b : Œì ‚ü∂ B) ‚Ü¶ Hom(dom(b*p), -)`. -/
noncomputable def pullbackDep.{v} {ùíû : Type*} [Category.{v} ùíû] [HasPullbacks ùíû] {E B : ùíû} (p : E ‚ü∂ B) :
    DepFunctor (yoneda.obj B) (ùíû ‚•§ Type v) where
  obj _ b := coyoneda.obj <| Opposite.op <| pullback b p
  map _ _ œÉ _ :=
    coyoneda.map <| Quiver.Hom.op <|
      pullback.lift (pullback.fst .. ‚â´ œÉ.unop) (pullback.snd ..) (by simp [pullback.condition])
  map_id _ b := by
    dsimp
    rw! [show ùüô _ ‚â´ b = b by simp]
    simp
  map_comp _ _ _ œÉ œÑ b := by
    ext
    dsimp
    rw! [show œÑ.unop ‚â´ œÉ.unop ‚â´ b = (œÑ.unop ‚â´ œÉ.unop) ‚â´ b by simp]
    simp only [‚Üê Category.assoc]
    congr 1
    ext <;> simp

@[simps]
def bifunctor_comp_snd {ùíü' : Type*} [Category ùíü'] (F : ùíü' ‚•§ ùíü) (P : ùíû ‚•§ ùíü ‚•§ ‚Ñ∞) : ùíû ‚•§ ùíü' ‚•§ ‚Ñ∞ where
  obj Œì := F ‚ãô P.obj Œì
  map œÉ := whiskerLeft F (P.map œÉ)

end CategoryTheory
