import Mathlib.CategoryTheory.Functor.Currying

import Poly.Util

import SEq.Tactic.DepRewrite

/-! # Bifunctors

We define some constructions on bifunctors (aka profunctors),
that is functors in two arguments.

Their utility in Poly is as a tool for packaging and composing natural equivalences.
For example, given `F,H : ùíû ‚ü∂ ‚Ñ∞` and `G,I : ùíü ‚ü∂ ‚Ñ∞`,
```
F(X) ‚ü∂ G(Y)
============
H(X) ‚ü∂ I(Y)
```
would be a natural isomorphism of bifunctors `ùíû·µí·µñ ‚•§ ùíü ‚•§ Type v`
given by `(X, Y) ‚Ü¶ F(X) ‚ü∂ G(Y)` and `(X, Y) ‚Ü¶ H(X) ‚ü∂ I(Y)`. -/

namespace CategoryTheory

variable {ùíû ùíü ‚Ñ∞ : Type*} [Category ùíû] [Category ùíü] [Category ‚Ñ∞]

/-- Natural isomorphism of bifunctors from naturality in both arguments. -/
def NatIso.ofComponents‚ÇÇ {F G : ùíû ‚•§ ùíü ‚•§ ‚Ñ∞}
    (app : ‚àÄ Œì X, (F.obj Œì).obj X ‚âÖ (G.obj Œì).obj X)
    (naturality_left : ‚àÄ {Œì Œî : ùíû} (X : ùíü) (œÉ : Œì ‚ü∂ Œî),
      (F.map œÉ).app X ‚â´ (app Œî X).hom = (app Œì X).hom ‚â´ (G.map œÉ).app X := by aesop_cat)
    (naturality_right : ‚àÄ {X Y : ùíü} (Œì : ùíû) (f : X ‚ü∂ Y),
      (F.obj Œì).map f ‚â´ (app Œì Y).hom = (app Œì X).hom ‚â´ (G.obj Œì).map f := by aesop_cat) :
    F ‚âÖ G :=
  NatIso.ofComponents
    (fun Œì => NatIso.ofComponents (app Œì) (fun f => by simpa using naturality_right Œì f))
    (fun œÉ => by ext X : 2; simpa using naturality_left X œÉ)

/-! ## Dependent functors -/

/-- A functor into `ùíü` that depends on `F`,
in other words `‚à´F ‚•§ ùíü` where all the `F(Œì)` are discrete,
spelled out in elementary terms.

(In the general case, we would have
`map : ‚àÄ ‚¶ÉŒì Œî‚¶Ñ ‚¶Éb : F.obj Œì‚¶Ñ ‚¶Éc : F.obj Œî‚¶Ñ
  (œÉ : Œì ‚ü∂ Œî) (f : F.map œÉ b ‚ü∂ c), obj b ‚ü∂ obj c`.)

Equivalently, it is a (lax or strict or something) transformation `F ‚ü∂ const ùíü`. -/
-- NOTE: A more mathlib-ready, general approach might use `‚à´F ‚•§ ùíü`,
-- and introduce a special-case constructor for discrete `F(Œì)`
-- with an argument for each field of this structure. -/
structure DepFunctor (F : ùíû ‚•§ Type*) (ùíü : Type*) [Category ùíü] where
  obj : ‚àÄ ‚¶ÉŒì‚¶Ñ, F.obj Œì ‚Üí ùíü
  -- Forded to avoid `eqToHom` in the axioms.
  map : ‚àÄ ‚¶ÉŒì Œî‚¶Ñ (œÉ : Œì ‚ü∂ Œî) (b : F.obj Œì) (c : F.obj Œî), c = F.map œÉ b ‚Üí (obj b ‚ü∂ obj c)
  map_id : ‚àÄ ‚¶ÉŒì‚¶Ñ b h, map (ùüô Œì) b b h = ùüô (obj b) := by aesop_cat
  /-- ### `simp`
  The two `map` equalities in the LHS imply the one in the RHS, but not vice-versa.
  This axiom is thus stated in a "packing" rather than an "unpacking" direction,
  so that `simp` can apply it automatically by matching `h‚ÇÅ` and `h‚ÇÇ`.
  However, we do not mark it `simp`;
  instead, a special case in the "unpacking" direction is `simp`. -/
  map_comp : ‚àÄ ‚¶ÉŒì Œî Œò‚¶Ñ (œÉ : Œì ‚ü∂ Œî) (œÑ : Œî ‚ü∂ Œò) b c d h‚ÇÅ h‚ÇÇ,
    map œÉ b c h‚ÇÅ ‚â´ map œÑ c d h‚ÇÇ = map (œÉ ‚â´ œÑ) b d (by simp [h‚ÇÅ, h‚ÇÇ]) := by aesop_cat

attribute [simp] DepFunctor.map_id

/-- Specialized variant of `map_comp` that `simp` can match against. -/
@[simp]
theorem DepFunctor.map_comp' {F : ùíû ‚•§ Type*} {G : DepFunctor F ùíü}
    ‚¶ÉŒì Œî Œò‚¶Ñ (œÉ : Œì ‚ü∂ Œî) (œÑ : Œî ‚ü∂ Œò) b h :
    G.map (œÉ ‚â´ œÑ) b (F.map œÑ (F.map œÉ b)) h = G.map œÉ b (F.map œÉ b) rfl ‚â´ G.map œÑ _ _ rfl :=
  (G.map_comp œÉ œÑ ..).symm

@[simps]
def DepFunctor.isoLeft.{v} {F‚ÇÅ F‚ÇÇ : ùíû ‚•§ Type v} {ùíü : Type*} [Category ùíü]
    (G : DepFunctor F‚ÇÅ ùíü) (i : F‚ÇÇ ‚âÖ F‚ÇÅ) : DepFunctor F‚ÇÇ ùíü where
  obj Œì b := G.obj (i.hom.app Œì b)
  map Œì _ œÉ _ _ eq := G.map œÉ _ _ (by simp [eq, FunctorToTypes.naturality])
  map_id := by simp
  map_comp := by simp [G.map_comp]

@[ext]
structure DepNatTrans {F : ùíû ‚•§ Type*} {ùíü : Type*} [Category ùíü] (G‚ÇÅ G‚ÇÇ : DepFunctor F ùíü) where
  app : ‚àÄ ‚¶ÉŒì‚¶Ñ (b : F.obj Œì), G‚ÇÅ.obj b ‚ü∂ G‚ÇÇ.obj b
  naturality : ‚àÄ ‚¶ÉŒì Œî‚¶Ñ (œÉ : Œì ‚ü∂ Œî) (b : F.obj Œì) (c : F.obj Œî) h,
    app b ‚â´ G‚ÇÇ.map œÉ b c h = G‚ÇÅ.map œÉ b c h ‚â´ app c := by aesop_cat

attribute [reassoc] DepNatTrans.naturality

@[simps]
instance (F : ùíû ‚•§ Type*) (ùíü : Type*) [Category ùíü] : Category (DepFunctor F ùíü) where
  Hom := DepNatTrans
  id G := { app := fun _ _ => ùüô _ }
  comp Œ∑ ŒΩ := {
    app := fun _ b => Œ∑.app b ‚â´ ŒΩ.app b
    naturality := by simp [Œ∑.naturality_assoc, ŒΩ.naturality]
  }

namespace DepNatTrans

variable {F : ùíû ‚•§ Type*} {ùíü : Type*} [Category ùíü] {Œì : ùíû} (b : F.obj Œì)

@[ext]
theorem ext' {G‚ÇÅ G‚ÇÇ : DepFunctor F ùíü} {Œ± Œ≤ : G‚ÇÅ ‚ü∂ G‚ÇÇ} (w : Œ±.app = Œ≤.app) : Œ± = Œ≤ :=
  DepNatTrans.ext w

@[simp]
theorem id_app (G‚ÇÅ : DepFunctor F ùíü) : (ùüô G‚ÇÅ : G‚ÇÅ ‚ü∂ G‚ÇÅ).app b = ùüô (G‚ÇÅ.obj b) := rfl

@[reassoc (attr := simp)]
theorem comp_app {G‚ÇÅ G‚ÇÇ G‚ÇÉ : DepFunctor F ùíü} (Œ± : G‚ÇÅ ‚ü∂ G‚ÇÇ) (Œ≤ : G‚ÇÇ ‚ü∂ G‚ÇÉ) :
    (Œ± ‚â´ Œ≤).app b = Œ±.app b ‚â´ Œ≤.app b := rfl

@[reassoc]
theorem naturality_app {‚Ñ∞ : Type*} [Category ‚Ñ∞] {G‚ÇÅ G‚ÇÇ : DepFunctor F (ùíü ‚•§ ‚Ñ∞)} (Œ± : G‚ÇÅ ‚ü∂ G‚ÇÇ)
    {Œì Œî : ùíû} (œÉ : Œì ‚ü∂ Œî) (b : F.obj Œì) (c : F.obj Œî) h (X : ùíü) :
    (G‚ÇÅ.map œÉ b c h).app X ‚â´ (Œ±.app c).app X = (Œ±.app b).app X ‚â´ (G‚ÇÇ.map œÉ b c h).app X :=
  (congr_fun (congr_arg NatTrans.app (Œ±.naturality œÉ b c h)) X).symm

end DepNatTrans

namespace DepNatIso

variable {F : ùíû ‚•§ Type*} {ùíü : Type*} [Category ùíü] {G‚ÇÅ G‚ÇÇ : DepFunctor F ùíü}

@[reassoc (attr := simp)]
theorem hom_inv_id_app {Œì : ùíû} (Œ± : G‚ÇÅ ‚âÖ G‚ÇÇ) (b : F.obj Œì) :
    Œ±.hom.app b ‚â´ Œ±.inv.app b = ùüô (G‚ÇÅ.obj b) := by
  simp [‚Üê DepNatTrans.comp_app]

@[reassoc (attr := simp)]
theorem inv_hom_id_app {Œì : ùíû} (Œ± : G‚ÇÅ ‚âÖ G‚ÇÇ) (b : F.obj Œì) :
    Œ±.inv.app b ‚â´ Œ±.hom.app b = ùüô (G‚ÇÇ.obj b) := by
  simp [‚Üê DepNatTrans.comp_app]

instance hom_app_isIso {Œì : ùíû} (Œ± : G‚ÇÅ ‚âÖ G‚ÇÇ) (b : F.obj Œì) : IsIso (Œ±.hom.app b) :=
  ‚ü®Œ±.inv.app b, by simp‚ü©

instance inv_app_isIso {Œì : ùíû} (Œ± : G‚ÇÅ ‚âÖ G‚ÇÇ) (b : F.obj Œì) : IsIso (Œ±.inv.app b) :=
  ‚ü®Œ±.hom.app b, by simp‚ü©

def ofComponents
    (app : ‚àÄ {Œì} (b : F.obj Œì), G‚ÇÅ.obj b ‚âÖ G‚ÇÇ.obj b)
    (naturality : ‚àÄ {Œì Œî} (œÉ : Œì ‚ü∂ Œî) (b : F.obj Œì) (c : F.obj Œî) h,
      (app b).hom ‚â´ G‚ÇÇ.map œÉ b c h = G‚ÇÅ.map œÉ b c h ‚â´ (app c).hom) :
    G‚ÇÅ ‚âÖ G‚ÇÇ where
  hom := { app := fun _ b => (app b).hom }
  inv := {
    app := fun _ b => (app b).inv
    naturality := fun _ _ œÉ b c h => by
      have : (app b).inv ‚â´ (app b).hom ‚â´ G‚ÇÇ.map œÉ b c h ‚â´ (app c).inv =
             (app b).inv ‚â´ G‚ÇÅ.map œÉ b c h ‚â´ (app c).hom ‚â´ (app c).inv := by
        simp [reassoc_of% naturality]
      simpa using this.symm
  }

variable {G‚ÇÅ G‚ÇÇ : DepFunctor F (Type v)}

@[simp]
theorem hom_inv_id_app_apply {Œì : ùíû} (Œ± : G‚ÇÅ ‚âÖ G‚ÇÇ) (X : F.obj Œì) (x) :
    Œ±.inv.app X (Œ±.hom.app X x) = x :=
  congr_fun (hom_inv_id_app Œ± X) x

@[simp]
theorem inv_hom_id_app_apply {Œì : ùíû} (Œ± : G‚ÇÅ ‚âÖ G‚ÇÇ) (X : F.obj Œì) (x) :
    Œ±.hom.app X (Œ±.inv.app X x) = x :=
  congr_fun (inv_hom_id_app Œ± X) x

variable {G‚ÇÅ G‚ÇÇ : DepFunctor F (ùíü ‚•§ Type v)}

@[simp]
theorem hom_inv_id_app_app_apply {Œì : ùíû} (Œ± : G‚ÇÅ ‚âÖ G‚ÇÇ) (b : F.obj Œì) (X : ùíü) (x) :
    (Œ±.inv.app b).app X ((Œ±.hom.app b).app X x) = x :=
  congr_fun (congr_fun (congr_arg NatTrans.app (hom_inv_id_app Œ± b)) X) x

@[simp]
theorem inv_hom_id_app_app_apply {Œì : ùíû} (Œ± : G‚ÇÅ ‚âÖ G‚ÇÇ) (b : F.obj Œì) (X : ùíü) (x) :
    (Œ±.hom.app b).app X ((Œ±.inv.app b).app X x) = x :=
  congr_fun (congr_fun (congr_arg NatTrans.app (inv_hom_id_app Œ± b)) X) x

end DepNatIso

/-! ## Dependent sum functors -/

/-- Given functors `F : ùíû ‚•§ Type v` and `G : ‚à´F ‚•§ ùíü ‚•§ Type v`,
produce the functor `(X, Y) ‚Ü¶ (b : F(X)) √ó G((X, b))(Y)`.
This is a dependent sum that varies naturally in its parameters `X, Y`. -/
@[simps!]
def Functor.Sigma.{v} {F : ùíû ‚•§ Type v} (G : DepFunctor F (ùíü ‚•§ Type v)) : ùíû ‚•§ ùíü ‚•§ Type v := by
  refine curry.obj {
    obj := fun (Œì, X) => (b : F.obj Œì) √ó ((G.obj b).obj X)
    map := fun (œÉ, f) ‚ü®b, e‚ü© =>
      ‚ü®F.map œÉ b, (G.map œÉ b _ rfl).app _ ((G.obj b).map f e)‚ü©
    map_id := ?_
    map_comp := ?_
  } <;> (
    intros
    ext ‚ü®b, e‚ü© : 1
    dsimp
    congr! 1 with h
    . simp
    . rw! [h]; simp [FunctorToTypes.naturality]
  )

def Functor.Sigma.isoCongrLeft.{v} (F‚ÇÅ F‚ÇÇ : ùíû ‚•§ Type v) (G : DepFunctor F‚ÇÅ (ùíü ‚•§ Type v))
    (i : F‚ÇÇ ‚âÖ F‚ÇÅ) : Functor.Sigma G ‚âÖ Functor.Sigma (G.isoLeft i) := by
  refine NatIso.ofComponents‚ÇÇ
    (fun Œì X => Equiv.toIso {
      toFun := fun ‚ü®b, e‚ü© => ‚ü®i.inv.app Œì b, cast (by simp) e‚ü©
      invFun := fun ‚ü®b, e‚ü© => ‚ü®i.hom.app Œì b, e‚ü©
      left_inv := fun ‚ü®_, _‚ü© => by simp
      right_inv := fun ‚ü®_, _‚ü© => by simp
    }) ?_ ?_ <;> (
      intros
      ext : 1
      dsimp
      apply let h := ?_; Sigma.ext h ?_
      . simp [FunctorToTypes.naturality]
      . dsimp [Sigma] at h ‚ä¢
        rw! [
          ‚Üê h,
          FunctorToTypes.inv_hom_id_app_apply,
          FunctorToTypes.inv_hom_id_app_apply,
        ]
        simp
    )

def Functor.Sigma.isoCongrRight.{v} (F : ùíû ‚•§ Type v) (G‚ÇÅ G‚ÇÇ : DepFunctor F (ùíü ‚•§ Type v))
    (i : G‚ÇÅ ‚âÖ G‚ÇÇ) :
    Functor.Sigma G‚ÇÅ ‚âÖ Functor.Sigma G‚ÇÇ :=
  NatIso.ofComponents‚ÇÇ
    (fun Œì X => Equiv.toIso {
      toFun := fun ‚ü®b, e‚ü© => ‚ü®b, (i.hom.app b).app X e‚ü©
      invFun := fun ‚ü®b, e‚ü© => ‚ü®b, (i.inv.app b).app X e‚ü©
      left_inv := fun ‚ü®b, e‚ü© => by simp
      right_inv := fun ‚ü®b, e‚ü© => by simp
    })
    (fun X œÉ => by
      ext ‚ü®b, e‚ü©
      have := congr_fun (DepNatTrans.naturality_app i.hom œÉ b _ rfl X) e
      dsimp at this
      simp [Sigma, this])
    (fun Œì f => by
      ext ‚ü®b, e‚ü©
      dsimp
      simp only [Sigma, prod_Hom, curry_obj_obj_map, Sigma.mk.injEq, FunctorToTypes.map_id_apply,
        heq_eq_eq, true_and]
      rw! [F.map_id Œì]
      simp [FunctorToTypes.naturality])

open Limits in
/-- The functor `(b : Œì ‚ü∂ B) ‚Ü¶ Hom(dom(b*p), -)`. -/
noncomputable def pullbackDep.{v} {ùíû : Type*} [Category.{v} ùíû] [HasPullbacks ùíû] {E B : ùíû} (p : E ‚ü∂ B) :
    DepFunctor (yoneda.obj B) (ùíû ‚•§ Type v) where
  obj _ b := coyoneda.obj <| Opposite.op <| pullback b p
  map _ _ œÉ _ _ eq :=
    coyoneda.map <| Quiver.Hom.op <|
      pullback.lift (pullback.fst .. ‚â´ œÉ.unop) (pullback.snd ..)
        (by rw [eq]; simp [pullback.condition])
  map_id := by simp
  map_comp := by
    intros
    ext : 3
    dsimp
    simp only [‚Üê Category.assoc]
    congr 1
    ext <;> simp

@[simps]
def bifunctor_comp_snd {ùíü' : Type*} [Category ùíü'] (F : ùíü' ‚•§ ùíü) (P : ùíû ‚•§ ùíü ‚•§ ‚Ñ∞) : ùíû ‚•§ ùíü' ‚•§ ‚Ñ∞ where
  obj Œì := F ‚ãô P.obj Œì
  map œÉ := whiskerLeft F (P.map œÉ)

/-- The functor `(g : X ‚ü∂ A) ‚Ü¶ ùíû/A(g, f)`. -/
@[simps]
def overDep (A : ùíû) : DepFunctor (yoneda.obj A) (Over A ‚•§ Type) where
  obj _ g := coyoneda.obj <| Opposite.op <| Over.mk g
  map _ _ œÉ f g eq := coyoneda.map <| Quiver.Hom.op <| Over.homMk œÉ.unop (by simp [eq])
  map_id := by simp
  map_comp := by
    intros
    ext : 3
    dsimp
    ext : 1
    simp

-- TODO: this in mathlib?
@[simps]
def Over_equiv {A : ùíû} (X : ùíû) (f : Over A) : (X ‚ü∂ f.left) ‚âÉ (b : X ‚ü∂ A) √ó (Over.mk b ‚ü∂ f) where
  toFun g := ‚ü®g ‚â´ f.hom, Over.homMk g rfl‚ü©
  invFun g := g.2.left
  left_inv _ := by simp
  right_inv := fun x => by
    dsimp; congr! 1 with h
    . simp
    . rw! [h]
      simp

/-- `ùíû(X, Over.forget f) ‚âÖ Œ£(g: X ‚ü∂ A), ùíû/A(g, f)` -/
def Over_iso (A : ùíû) :
    bifunctor_comp_snd (Over.forget A) (coyoneda (C := ùíû)) ‚âÖ Functor.Sigma (overDep A) := by
  refine NatIso.ofComponents‚ÇÇ (fun Œì U => Equiv.toIso <| Over_equiv Œì.unop U) ?_ ?_ <;> (
    intros
    dsimp
    ext : 1
    apply let h := ?_; Sigma.ext h ?_
    . simp
    . dsimp at h ‚ä¢
      rw! [h]
      apply heq_of_eq
      ext
      simp
  )

end CategoryTheory
